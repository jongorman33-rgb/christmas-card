<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Procedural Christmas - Engineer's Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; }
        canvas { display: block; }
        #info {
            position: absolute; top: 10px; left: 10px; color: #aaa; 
            font-family: monospace; font-size: 12px; pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">
        SYSTEM: Three.js Voxel Render<br>
        MODULE: Dynamic Weather Control<br>
        INPUT: Use panel (top-right) to adjust parameters.
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- 1. CONFIGURATION & STATE ---
        const params = {
            snowSpeed: 1.0,
            windX: 0.0,
            moonBrightness: 0.6,
            houseLight: true
        };

        // --- 2. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 3. LIGHTING ---
        const moonLight = new THREE.DirectionalLight(0xaaccff, params.moonBrightness);
        moonLight.position.set(-20, 50, -20);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        scene.add(moonLight);

        const ambientLight = new THREE.AmbientLight(0x404060, 0.4); 
        scene.add(ambientLight);

        // --- 4. VOXEL ENGINE ---
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        function createVoxel(x, y, z, color, size = {x:1, y:1, z:1}, emissive = 0x000000) {
            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.9,
                emissive: emissive
            });
            const mesh = new THREE.Mesh(boxGeo, material);
            mesh.position.set(x, y, z);
            mesh.scale.set(size.x, size.y, size.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // --- 5. SCENE ASSEMBLY ---
        
        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // House Group
        const houseGroup = new THREE.Group();
        // Structure
        houseGroup.add(createVoxel(0, 2, 0, 0x6d4f38, {x: 6, y: 4, z: 6}));
        houseGroup.add(createVoxel(2, 5, 2, 0x333333, {x: 1, y: 3, z: 1})); // Chimney
        houseGroup.add(createVoxel(0, 1, 3.1, 0x3d2817, {x: 1.5, y: 2, z: 0.2})); // Door
        
        // Roof
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
        const roof = new THREE.Mesh(new THREE.ConeGeometry(5, 3, 4), roofMat);
        roof.position.set(0, 5.5, 0);
        roof.rotation.y = Math.PI / 4;
        houseGroup.add(roof);

        // Windows
        const winColor = 0xffaa00;
        houseGroup.add(createVoxel(-2, 2, 3.1, winColor, {x: 1.5, y: 1.5, z: 0.1}, 0xffaa00));
        houseGroup.add(createVoxel(2, 2, 3.1, winColor, {x: 1.5, y: 1.5, z: 0.1}, 0xffaa00));

        // House Light
        const housePointLight = new THREE.PointLight(0xffaa00, 5, 15);
        housePointLight.position.set(0, 2, 4);
        houseGroup.add(housePointLight);

        scene.add(houseGroup);

        // Trees
        function createTree(x, z) {
            const t = new THREE.Group();
            t.add(createVoxel(0, 1.5, 0, 0x4a3c31, {x: 1, y: 3, z: 1}));
            t.add(createVoxel(0, 3.5, 0, 0x085e13, {x: 5, y: 1, z: 5}));
            t.add(createVoxel(0, 4.5, 0, 0x085e13, {x: 3, y: 1, z: 3}));
            t.add(createVoxel(0, 5.5, 0, 0x085e13, {x: 1, y: 1, z: 1}));
            t.add(createVoxel(0, 6.1, 0, 0xffffff, {x: 1, y: 0.2, z: 1}));
            t.position.set(x, 0, z);
            scene.add(t);
        }
        createTree(-7, -5);
        createTree(8, -2);
        createTree(-6, 6);

        // --- 6. SNOW SYSTEM ---
        const snowCount = 2000;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(snowCount * 3);
        const snowVel = []; 

        for(let i=0; i<snowCount; i++) {
            snowPos[i*3] = (Math.random() - 0.5) * 60;
            snowPos[i*3+1] = Math.random() * 40;
            snowPos[i*3+2] = (Math.random() - 0.5) * 60;
            snowVel.push((Math.random() * 0.1) + 0.05);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowSystem = new THREE.Points(
            snowGeo, 
            new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 })
        );
        scene.add(snowSystem);

        // --- 7. GUI SETUP ---
        const gui = new GUI();
        const folderWeather = gui.addFolder('Weather Conditions');
        folderWeather.add(params, 'snowSpeed', 0, 5).name('Fall Speed');
        folderWeather.add(params, 'windX', -0.5, 0.5).name('Wind Force');
        
        const folderLight = gui.addFolder('Lighting');
        folderLight.add(params, 'moonBrightness', 0, 2).name('Moonlight').onChange(v => {
            moonLight.intensity = v;
        });
        folderLight.add(params, 'houseLight').name('House Lights').onChange(v => {
            housePointLight.intensity = v ? 5 : 0;
        });

        // --- 8. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const positions = snowSystem.geometry.attributes.position.array;
            
            for(let i=0; i<snowCount; i++) {
                // Apply Velocity + Speed parameter
                positions[i*3+1] -= snowVel[i] * params.snowSpeed;
                
                // Apply Wind parameter
                positions[i*3] += params.windX;

                // Teleport Logic (Infinite Loop)
                if (positions[i*3+1] < 0) {
                    positions[i*3+1] = 40;
                    // Reset X slightly random to prevent wind "stacking" particles
                    positions[i*3] = (Math.random() - 0.5) * 60; 
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>